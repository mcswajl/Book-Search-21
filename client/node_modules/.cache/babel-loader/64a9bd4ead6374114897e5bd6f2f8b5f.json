{"ast":null,"code":"import { syntaxError } from '../error/syntaxError.mjs';\nimport { Kind } from './kinds.mjs';\nimport { Location, OperationTypeNode } from './ast.mjs';\nimport { TokenKind } from './tokenKind.mjs';\nimport { Source, isSource } from './source.mjs';\nimport { DirectiveLocation } from './directiveLocation.mjs';\nimport { Lexer, isPunctuatorTokenKind } from './lexer.mjs';\n/**\r\n * Configuration options to control parser behavior\r\n */\n\n/**\r\n * Given a GraphQL source, parses it into a Document.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n */\n\nexport function parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\r\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\r\n * that value.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n *\r\n * This is useful within tools that operate upon GraphQL Values directly and\r\n * in isolation of complete GraphQL documents.\r\n *\r\n * Consider providing the results to the utility function: valueFromAST().\r\n */\n\nexport function parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\r\n * Similar to parseValue(), but raises a parse error if it encounters a\r\n * variable. The return type will be a constant value.\r\n */\n\nexport function parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\r\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\r\n * that type.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n *\r\n * This is useful within tools that operate upon GraphQL Types directly and\r\n * in isolation of complete GraphQL documents.\r\n *\r\n * Consider providing the results to the utility function: typeFromAST().\r\n */\n\nexport function parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\r\n * This class is exported only to assist people in implementing their own parsers\r\n * without duplicating too much code and should be used only as last resort for cases\r\n * such as experimental syntax or if certain features could not be contributed upstream.\r\n *\r\n * It is still part of the internal API and is versioned, so any changes to it are never\r\n * considered breaking changes. If you still need to support multiple versions of the\r\n * library, please use the `versionInfo` variable for version detection.\r\n *\r\n * @internal\r\n */\n\nexport class Parser {\n  constructor(source, options) {\n    const sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\r\n   * Converts a name lex token into a name parse node.\r\n   */\n\n\n  parseName() {\n    const token = this.expectToken(TokenKind.NAME);\n    return this.node(token, {\n      kind: Kind.NAME,\n      value: token.value\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\r\n   * Document : Definition+\r\n   */\n\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF)\n    });\n  }\n  /**\r\n   * Definition :\r\n   *   - ExecutableDefinition\r\n   *   - TypeSystemDefinition\r\n   *   - TypeSystemExtension\r\n   *\r\n   * ExecutableDefinition :\r\n   *   - OperationDefinition\r\n   *   - FragmentDefinition\r\n   *\r\n   * TypeSystemDefinition :\r\n   *   - SchemaDefinition\r\n   *   - TypeDefinition\r\n   *   - DirectiveDefinition\r\n   *\r\n   * TypeDefinition :\r\n   *   - ScalarTypeDefinition\r\n   *   - ObjectTypeDefinition\r\n   *   - InterfaceTypeDefinition\r\n   *   - UnionTypeDefinition\r\n   *   - EnumTypeDefinition\r\n   *   - InputObjectTypeDefinition\r\n   */\n\n\n  parseDefinition() {\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n\n      if (hasDescription) {\n        throw syntaxError(this._lexer.source, this._lexer.token.start, 'Unexpected description, descriptions are supported only on type definitions.');\n      }\n\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\r\n   * OperationDefinition :\r\n   *  - SelectionSet\r\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\r\n   */\n\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet()\n      });\n    }\n\n    const operation = this.parseOperationType();\n    let name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return this.node(start, {\n      kind: Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet()\n    });\n  }\n  /**\r\n   * OperationType : one of query mutation subscription\r\n   */\n\n\n  parseOperationType() {\n    const operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return OperationTypeNode.QUERY;\n\n      case 'mutation':\n        return OperationTypeNode.MUTATION;\n\n      case 'subscription':\n        return OperationTypeNode.SUBSCRIPTION;\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\r\n   * VariableDefinitions : ( VariableDefinition+ )\r\n   */\n\n\n  parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  }\n  /**\r\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\r\n   */\n\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : undefined,\n      directives: this.parseConstDirectives()\n    });\n  }\n  /**\r\n   * Variable : $ Name\r\n   */\n\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: Kind.VARIABLE,\n      name: this.parseName()\n    });\n  }\n  /**\r\n   * ```\r\n   * SelectionSet : { Selection+ }\r\n   * ```\r\n   */\n\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R)\n    });\n  }\n  /**\r\n   * Selection :\r\n   *   - Field\r\n   *   - FragmentSpread\r\n   *   - InlineFragment\r\n   */\n\n\n  parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\r\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\r\n   *\r\n   * Alias : Name :\r\n   */\n\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return this.node(start, {\n      kind: Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined\n    });\n  }\n  /**\r\n   * Arguments[Const] : ( Argument[?Const]+ )\r\n   */\n\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\r\n   * Argument[Const] : Name : Value[?Const]\r\n   */\n\n\n  parseArgument(isConst = false) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst)\n    });\n  }\n\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\r\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\r\n   *\r\n   * FragmentSpread : ... FragmentName Directives?\r\n   *\r\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\r\n   */\n\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false)\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet()\n    });\n  }\n  /**\r\n   * FragmentDefinition :\r\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\r\n   *\r\n   * TypeCondition : NamedType\r\n   */\n\n\n  parseFragmentDefinition() {\n    var _this$_options;\n\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.allowLegacyFragmentVariables) === true) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet()\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet()\n    });\n  }\n  /**\r\n   * FragmentName : Name but not `on`\r\n   */\n\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\r\n   * Value[Const] :\r\n   *   - [~Const] Variable\r\n   *   - IntValue\r\n   *   - FloatValue\r\n   *   - StringValue\r\n   *   - BooleanValue\r\n   *   - NullValue\r\n   *   - EnumValue\r\n   *   - ListValue[?Const]\r\n   *   - ObjectValue[?Const]\r\n   *\r\n   * BooleanValue : one of `true` `false`\r\n   *\r\n   * NullValue : `null`\r\n   *\r\n   * EnumValue : Name but not `true`, `false` or `null`\r\n   */\n\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: Kind.INT,\n          value: token.value\n        });\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: Kind.FLOAT,\n          value: token.value\n        });\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: true\n            });\n\n          case 'false':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: false\n            });\n\n          case 'null':\n            return this.node(token, {\n              kind: Kind.NULL\n            });\n\n          default:\n            return this.node(token, {\n              kind: Kind.ENUM,\n              value: token.value\n            });\n        }\n\n      case TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(TokenKind.DOLLAR);\n\n          if (this._lexer.token.kind === TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw syntaxError(this._lexer.source, token.start, `Unexpected variable \"$${varName}\" in constant value.`);\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n\n        return this.parseVariable();\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n\n  parseStringLiteral() {\n    const token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return this.node(token, {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING\n    });\n  }\n  /**\r\n   * ListValue[Const] :\r\n   *   - [ ]\r\n   *   - [ Value[?Const]+ ]\r\n   */\n\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)\n    });\n  }\n  /**\r\n   * ```\r\n   * ObjectValue[Const] :\r\n   *   - { }\r\n   *   - { ObjectField[?Const]+ }\r\n   * ```\r\n   */\n\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)\n    });\n  }\n  /**\r\n   * ObjectField[Const] : Name : Value[?Const]\r\n   */\n\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst)\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\r\n   * Directives[Const] : Directive[?Const]+\r\n   */\n\n\n  parseDirectives(isConst) {\n    const directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\r\n   * ```\r\n   * Directive[Const] : @ Name Arguments[?Const]?\r\n   * ```\r\n   */\n\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return this.node(start, {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst)\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\r\n   * Type :\r\n   *   - NamedType\r\n   *   - ListType\r\n   *   - NonNullType\r\n   */\n\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: Kind.LIST_TYPE,\n        type: innerType\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return this.node(start, {\n        kind: Kind.NON_NULL_TYPE,\n        type\n      });\n    }\n\n    return type;\n  }\n  /**\r\n   * NamedType : Name\r\n   */\n\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName()\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n\n  peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\r\n   * Description : StringValue\r\n   */\n\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\r\n   * ```\r\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\r\n   * ```\r\n   */\n\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return this.node(start, {\n      kind: Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes\n    });\n  }\n  /**\r\n   * OperationTypeDefinition : OperationType : NamedType\r\n   */\n\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type\n    });\n  }\n  /**\r\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\r\n   */\n\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives\n    });\n  }\n  /**\r\n   * ObjectTypeDefinition :\r\n   *   Description?\r\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\r\n   */\n\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\r\n   * ImplementsInterfaces :\r\n   *   - implements `&`? NamedType\r\n   *   - ImplementsInterfaces & NamedType\r\n   */\n\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements') ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];\n  }\n  /**\r\n   * ```\r\n   * FieldsDefinition : { FieldDefinition+ }\r\n   * ```\r\n   */\n\n\n  parseFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  }\n  /**\r\n   * FieldDefinition :\r\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\r\n   */\n\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives\n    });\n  }\n  /**\r\n   * ArgumentsDefinition : ( InputValueDefinition+ )\r\n   */\n\n\n  parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  }\n  /**\r\n   * InputValueDefinition :\r\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\r\n   */\n\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives\n    });\n  }\n  /**\r\n   * InterfaceTypeDefinition :\r\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\r\n   */\n\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\r\n   * UnionTypeDefinition :\r\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\r\n   */\n\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types\n    });\n  }\n  /**\r\n   * UnionMemberTypes :\r\n   *   - = `|`? NamedType\r\n   *   - UnionMemberTypes | NamedType\r\n   */\n\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];\n  }\n  /**\r\n   * EnumTypeDefinition :\r\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\r\n   */\n\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values\n    });\n  }\n  /**\r\n   * ```\r\n   * EnumValuesDefinition : { EnumValueDefinition+ }\r\n   * ```\r\n   */\n\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  }\n  /**\r\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\r\n   */\n\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives\n    });\n  }\n  /**\r\n   * EnumValue : Name but not `true`, `false` or `null`\r\n   */\n\n\n  parseEnumValueName() {\n    if (this._lexer.token.value === 'true' || this._lexer.token.value === 'false' || this._lexer.token.value === 'null') {\n      throw syntaxError(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);\n    }\n\n    return this.parseName();\n  }\n  /**\r\n   * InputObjectTypeDefinition :\r\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\r\n   */\n\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields\n    });\n  }\n  /**\r\n   * ```\r\n   * InputFieldsDefinition : { InputValueDefinition+ }\r\n   * ```\r\n   */\n\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  }\n  /**\r\n   * TypeSystemExtension :\r\n   *   - SchemaExtension\r\n   *   - TypeExtension\r\n   *\r\n   * TypeExtension :\r\n   *   - ScalarTypeExtension\r\n   *   - ObjectTypeExtension\r\n   *   - InterfaceTypeExtension\r\n   *   - UnionTypeExtension\r\n   *   - EnumTypeExtension\r\n   *   - InputObjectTypeDefinition\r\n   */\n\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\r\n   * ```\r\n   * SchemaExtension :\r\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\r\n   *  - extend schema Directives[Const]\r\n   * ```\r\n   */\n\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes\n    });\n  }\n  /**\r\n   * ScalarTypeExtension :\r\n   *   - extend scalar Name Directives[Const]\r\n   */\n\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives\n    });\n  }\n  /**\r\n   * ObjectTypeExtension :\r\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\r\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\r\n   *  - extend type Name ImplementsInterfaces\r\n   */\n\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\r\n   * InterfaceTypeExtension :\r\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\r\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\r\n   *  - extend interface Name ImplementsInterfaces\r\n   */\n\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\r\n   * UnionTypeExtension :\r\n   *   - extend union Name Directives[Const]? UnionMemberTypes\r\n   *   - extend union Name Directives[Const]\r\n   */\n\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types\n    });\n  }\n  /**\r\n   * EnumTypeExtension :\r\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\r\n   *   - extend enum Name Directives[Const]\r\n   */\n\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values\n    });\n  }\n  /**\r\n   * InputObjectTypeExtension :\r\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\r\n   *   - extend input Name Directives[Const]\r\n   */\n\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields\n    });\n  }\n  /**\r\n   * ```\r\n   * DirectiveDefinition :\r\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\r\n   * ```\r\n   */\n\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations\n    });\n  }\n  /**\r\n   * DirectiveLocations :\r\n   *   - `|`? DirectiveLocation\r\n   *   - DirectiveLocations | DirectiveLocation\r\n   */\n\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\r\n   * DirectiveLocation :\r\n   *   - ExecutableDirectiveLocation\r\n   *   - TypeSystemDirectiveLocation\r\n   *\r\n   * ExecutableDirectiveLocation : one of\r\n   *   `QUERY`\r\n   *   `MUTATION`\r\n   *   `SUBSCRIPTION`\r\n   *   `FIELD`\r\n   *   `FRAGMENT_DEFINITION`\r\n   *   `FRAGMENT_SPREAD`\r\n   *   `INLINE_FRAGMENT`\r\n   *\r\n   * TypeSystemDirectiveLocation : one of\r\n   *   `SCHEMA`\r\n   *   `SCALAR`\r\n   *   `OBJECT`\r\n   *   `FIELD_DEFINITION`\r\n   *   `ARGUMENT_DEFINITION`\r\n   *   `INTERFACE`\r\n   *   `UNION`\r\n   *   `ENUM`\r\n   *   `ENUM_VALUE`\r\n   *   `INPUT_OBJECT`\r\n   *   `INPUT_FIELD_DEFINITION`\r\n   */\n\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\r\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\r\n   * location object, used to identify the place in the source that created a\r\n   * given parsed object.\r\n   */\n\n\n  node(startToken, node) {\n    var _this$_options2;\n\n    if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.noLocation) !== true) {\n      node.loc = new Location(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n\n    return node;\n  }\n  /**\r\n   * Determines if the next token is of a given kind\r\n   */\n\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\r\n   * If the next token is of the given kind, return that token after advancing the lexer.\r\n   * Otherwise, do not change the parser state and throw an error.\r\n   */\n\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`);\n  }\n  /**\r\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\r\n   * Otherwise, do not change the parser state and return \"false\".\r\n   */\n\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\r\n   * If the next token is a given keyword, advance the lexer.\r\n   * Otherwise, do not change the parser state and throw an error.\r\n   */\n\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(this._lexer.source, token.start, `Expected \"${value}\", found ${getTokenDesc(token)}.`);\n    }\n  }\n  /**\r\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\r\n   * Otherwise, do not change the parser state and return \"false\".\r\n   */\n\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\r\n   * Helper function for creating an error when an unexpected lexed token is encountered.\r\n   */\n\n\n  unexpected(atToken) {\n    const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);\n  }\n  /**\r\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\r\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\n\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\r\n   * Returns a list of parse nodes, determined by the parseFn.\r\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\r\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\n\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\r\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\r\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\n\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\r\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\r\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\r\n   * Advances the parser to the next lex token after last item in the list.\r\n   */\n\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  }\n\n}\n/**\r\n * A helper function to describe a token as a string for debugging.\r\n */\n\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\r\n * A helper function to describe a token kind as a string for debugging.\r\n */\n\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? `\"${kind}\"` : kind;\n}","map":{"version":3,"sources":["C:/BootCamp/Book-Search-21/node_modules/graphql/language/parser.mjs"],"names":["syntaxError","Kind","Location","OperationTypeNode","TokenKind","Source","isSource","DirectiveLocation","Lexer","isPunctuatorTokenKind","parse","source","options","parser","Parser","parseDocument","parseValue","expectToken","SOF","value","parseValueLiteral","EOF","parseConstValue","parseConstValueLiteral","parseType","type","parseTypeReference","constructor","sourceObj","_lexer","_options","parseName","token","NAME","node","kind","DOCUMENT","definitions","many","parseDefinition","peek","BRACE_L","parseOperationDefinition","hasDescription","peekDescription","keywordToken","lookahead","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","start","parseFragmentDefinition","parseTypeSystemExtension","unexpected","OPERATION_DEFINITION","operation","QUERY","name","undefined","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","MUTATION","SUBSCRIPTION","optionalMany","PAREN_L","parseVariableDefinition","PAREN_R","VARIABLE_DEFINITION","variable","parseVariable","COLON","defaultValue","expectOptionalToken","EQUALS","parseConstDirectives","DOLLAR","VARIABLE","SELECTION_SET","selections","parseSelection","BRACE_R","SPREAD","parseFragment","parseField","nameOrAlias","alias","FIELD","arguments","parseArguments","isConst","item","parseConstArgument","parseArgument","ARGUMENT","hasTypeCondition","expectOptionalKeyword","FRAGMENT_SPREAD","parseFragmentName","INLINE_FRAGMENT","typeCondition","parseNamedType","_this$_options","expectKeyword","allowLegacyFragmentVariables","FRAGMENT_DEFINITION","BRACKET_L","parseList","parseObject","INT","advance","FLOAT","STRING","BLOCK_STRING","parseStringLiteral","BOOLEAN","NULL","ENUM","varName","block","LIST","values","any","BRACKET_R","parseObjectField","OBJECT","fields","OBJECT_FIELD","AT","push","parseDirective","DIRECTIVE","innerType","LIST_TYPE","BANG","NON_NULL_TYPE","NAMED_TYPE","parseDescription","description","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","interfaces","parseImplementsInterfaces","parseFieldsDefinition","OBJECT_TYPE_DEFINITION","delimitedMany","AMP","parseFieldDefinition","args","parseArgumentDefs","FIELD_DEFINITION","parseInputValueDef","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","types","parseUnionMemberTypes","UNION_TYPE_DEFINITION","PIPE","parseEnumValuesDefinition","ENUM_TYPE_DEFINITION","parseEnumValueDefinition","parseEnumValueName","ENUM_VALUE_DEFINITION","getTokenDesc","parseInputFieldsDefinition","INPUT_OBJECT_TYPE_DEFINITION","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","length","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","repeatable","locations","parseDirectiveLocations","DIRECTIVE_DEFINITION","parseDirectiveLocation","Object","prototype","hasOwnProperty","call","startToken","_this$_options2","noLocation","loc","lastToken","getTokenKindDesc","atToken","openKind","parseFn","closeKind","nodes","delimiterKind"],"mappings":"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","sourcesContent":["import { syntaxError } from '../error/syntaxError.mjs';\r\nimport { Kind } from './kinds.mjs';\r\nimport { Location, OperationTypeNode } from './ast.mjs';\r\nimport { TokenKind } from './tokenKind.mjs';\r\nimport { Source, isSource } from './source.mjs';\r\nimport { DirectiveLocation } from './directiveLocation.mjs';\r\nimport { Lexer, isPunctuatorTokenKind } from './lexer.mjs';\r\n/**\r\n * Configuration options to control parser behavior\r\n */\r\n\r\n/**\r\n * Given a GraphQL source, parses it into a Document.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n */\r\nexport function parse(source, options) {\r\n  const parser = new Parser(source, options);\r\n  return parser.parseDocument();\r\n}\r\n/**\r\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\r\n * that value.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n *\r\n * This is useful within tools that operate upon GraphQL Values directly and\r\n * in isolation of complete GraphQL documents.\r\n *\r\n * Consider providing the results to the utility function: valueFromAST().\r\n */\r\n\r\nexport function parseValue(source, options) {\r\n  const parser = new Parser(source, options);\r\n  parser.expectToken(TokenKind.SOF);\r\n  const value = parser.parseValueLiteral(false);\r\n  parser.expectToken(TokenKind.EOF);\r\n  return value;\r\n}\r\n/**\r\n * Similar to parseValue(), but raises a parse error if it encounters a\r\n * variable. The return type will be a constant value.\r\n */\r\n\r\nexport function parseConstValue(source, options) {\r\n  const parser = new Parser(source, options);\r\n  parser.expectToken(TokenKind.SOF);\r\n  const value = parser.parseConstValueLiteral();\r\n  parser.expectToken(TokenKind.EOF);\r\n  return value;\r\n}\r\n/**\r\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\r\n * that type.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n *\r\n * This is useful within tools that operate upon GraphQL Types directly and\r\n * in isolation of complete GraphQL documents.\r\n *\r\n * Consider providing the results to the utility function: typeFromAST().\r\n */\r\n\r\nexport function parseType(source, options) {\r\n  const parser = new Parser(source, options);\r\n  parser.expectToken(TokenKind.SOF);\r\n  const type = parser.parseTypeReference();\r\n  parser.expectToken(TokenKind.EOF);\r\n  return type;\r\n}\r\n/**\r\n * This class is exported only to assist people in implementing their own parsers\r\n * without duplicating too much code and should be used only as last resort for cases\r\n * such as experimental syntax or if certain features could not be contributed upstream.\r\n *\r\n * It is still part of the internal API and is versioned, so any changes to it are never\r\n * considered breaking changes. If you still need to support multiple versions of the\r\n * library, please use the `versionInfo` variable for version detection.\r\n *\r\n * @internal\r\n */\r\n\r\nexport class Parser {\r\n  constructor(source, options) {\r\n    const sourceObj = isSource(source) ? source : new Source(source);\r\n    this._lexer = new Lexer(sourceObj);\r\n    this._options = options;\r\n  }\r\n  /**\r\n   * Converts a name lex token into a name parse node.\r\n   */\r\n\r\n  parseName() {\r\n    const token = this.expectToken(TokenKind.NAME);\r\n    return this.node(token, {\r\n      kind: Kind.NAME,\r\n      value: token.value,\r\n    });\r\n  } // Implements the parsing rules in the Document section.\r\n\r\n  /**\r\n   * Document : Definition+\r\n   */\r\n\r\n  parseDocument() {\r\n    return this.node(this._lexer.token, {\r\n      kind: Kind.DOCUMENT,\r\n      definitions: this.many(\r\n        TokenKind.SOF,\r\n        this.parseDefinition,\r\n        TokenKind.EOF,\r\n      ),\r\n    });\r\n  }\r\n  /**\r\n   * Definition :\r\n   *   - ExecutableDefinition\r\n   *   - TypeSystemDefinition\r\n   *   - TypeSystemExtension\r\n   *\r\n   * ExecutableDefinition :\r\n   *   - OperationDefinition\r\n   *   - FragmentDefinition\r\n   *\r\n   * TypeSystemDefinition :\r\n   *   - SchemaDefinition\r\n   *   - TypeDefinition\r\n   *   - DirectiveDefinition\r\n   *\r\n   * TypeDefinition :\r\n   *   - ScalarTypeDefinition\r\n   *   - ObjectTypeDefinition\r\n   *   - InterfaceTypeDefinition\r\n   *   - UnionTypeDefinition\r\n   *   - EnumTypeDefinition\r\n   *   - InputObjectTypeDefinition\r\n   */\r\n\r\n  parseDefinition() {\r\n    if (this.peek(TokenKind.BRACE_L)) {\r\n      return this.parseOperationDefinition();\r\n    } // Many definitions begin with a description and require a lookahead.\r\n\r\n    const hasDescription = this.peekDescription();\r\n    const keywordToken = hasDescription\r\n      ? this._lexer.lookahead()\r\n      : this._lexer.token;\r\n\r\n    if (keywordToken.kind === TokenKind.NAME) {\r\n      switch (keywordToken.value) {\r\n        case 'schema':\r\n          return this.parseSchemaDefinition();\r\n\r\n        case 'scalar':\r\n          return this.parseScalarTypeDefinition();\r\n\r\n        case 'type':\r\n          return this.parseObjectTypeDefinition();\r\n\r\n        case 'interface':\r\n          return this.parseInterfaceTypeDefinition();\r\n\r\n        case 'union':\r\n          return this.parseUnionTypeDefinition();\r\n\r\n        case 'enum':\r\n          return this.parseEnumTypeDefinition();\r\n\r\n        case 'input':\r\n          return this.parseInputObjectTypeDefinition();\r\n\r\n        case 'directive':\r\n          return this.parseDirectiveDefinition();\r\n      }\r\n\r\n      if (hasDescription) {\r\n        throw syntaxError(\r\n          this._lexer.source,\r\n          this._lexer.token.start,\r\n          'Unexpected description, descriptions are supported only on type definitions.',\r\n        );\r\n      }\r\n\r\n      switch (keywordToken.value) {\r\n        case 'query':\r\n        case 'mutation':\r\n        case 'subscription':\r\n          return this.parseOperationDefinition();\r\n\r\n        case 'fragment':\r\n          return this.parseFragmentDefinition();\r\n\r\n        case 'extend':\r\n          return this.parseTypeSystemExtension();\r\n      }\r\n    }\r\n\r\n    throw this.unexpected(keywordToken);\r\n  } // Implements the parsing rules in the Operations section.\r\n\r\n  /**\r\n   * OperationDefinition :\r\n   *  - SelectionSet\r\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\r\n   */\r\n\r\n  parseOperationDefinition() {\r\n    const start = this._lexer.token;\r\n\r\n    if (this.peek(TokenKind.BRACE_L)) {\r\n      return this.node(start, {\r\n        kind: Kind.OPERATION_DEFINITION,\r\n        operation: OperationTypeNode.QUERY,\r\n        name: undefined,\r\n        variableDefinitions: [],\r\n        directives: [],\r\n        selectionSet: this.parseSelectionSet(),\r\n      });\r\n    }\r\n\r\n    const operation = this.parseOperationType();\r\n    let name;\r\n\r\n    if (this.peek(TokenKind.NAME)) {\r\n      name = this.parseName();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.OPERATION_DEFINITION,\r\n      operation,\r\n      name,\r\n      variableDefinitions: this.parseVariableDefinitions(),\r\n      directives: this.parseDirectives(false),\r\n      selectionSet: this.parseSelectionSet(),\r\n    });\r\n  }\r\n  /**\r\n   * OperationType : one of query mutation subscription\r\n   */\r\n\r\n  parseOperationType() {\r\n    const operationToken = this.expectToken(TokenKind.NAME);\r\n\r\n    switch (operationToken.value) {\r\n      case 'query':\r\n        return OperationTypeNode.QUERY;\r\n\r\n      case 'mutation':\r\n        return OperationTypeNode.MUTATION;\r\n\r\n      case 'subscription':\r\n        return OperationTypeNode.SUBSCRIPTION;\r\n    }\r\n\r\n    throw this.unexpected(operationToken);\r\n  }\r\n  /**\r\n   * VariableDefinitions : ( VariableDefinition+ )\r\n   */\r\n\r\n  parseVariableDefinitions() {\r\n    return this.optionalMany(\r\n      TokenKind.PAREN_L,\r\n      this.parseVariableDefinition,\r\n      TokenKind.PAREN_R,\r\n    );\r\n  }\r\n  /**\r\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\r\n   */\r\n\r\n  parseVariableDefinition() {\r\n    return this.node(this._lexer.token, {\r\n      kind: Kind.VARIABLE_DEFINITION,\r\n      variable: this.parseVariable(),\r\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\r\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS)\r\n        ? this.parseConstValueLiteral()\r\n        : undefined,\r\n      directives: this.parseConstDirectives(),\r\n    });\r\n  }\r\n  /**\r\n   * Variable : $ Name\r\n   */\r\n\r\n  parseVariable() {\r\n    const start = this._lexer.token;\r\n    this.expectToken(TokenKind.DOLLAR);\r\n    return this.node(start, {\r\n      kind: Kind.VARIABLE,\r\n      name: this.parseName(),\r\n    });\r\n  }\r\n  /**\r\n   * ```\r\n   * SelectionSet : { Selection+ }\r\n   * ```\r\n   */\r\n\r\n  parseSelectionSet() {\r\n    return this.node(this._lexer.token, {\r\n      kind: Kind.SELECTION_SET,\r\n      selections: this.many(\r\n        TokenKind.BRACE_L,\r\n        this.parseSelection,\r\n        TokenKind.BRACE_R,\r\n      ),\r\n    });\r\n  }\r\n  /**\r\n   * Selection :\r\n   *   - Field\r\n   *   - FragmentSpread\r\n   *   - InlineFragment\r\n   */\r\n\r\n  parseSelection() {\r\n    return this.peek(TokenKind.SPREAD)\r\n      ? this.parseFragment()\r\n      : this.parseField();\r\n  }\r\n  /**\r\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\r\n   *\r\n   * Alias : Name :\r\n   */\r\n\r\n  parseField() {\r\n    const start = this._lexer.token;\r\n    const nameOrAlias = this.parseName();\r\n    let alias;\r\n    let name;\r\n\r\n    if (this.expectOptionalToken(TokenKind.COLON)) {\r\n      alias = nameOrAlias;\r\n      name = this.parseName();\r\n    } else {\r\n      name = nameOrAlias;\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.FIELD,\r\n      alias,\r\n      name,\r\n      arguments: this.parseArguments(false),\r\n      directives: this.parseDirectives(false),\r\n      selectionSet: this.peek(TokenKind.BRACE_L)\r\n        ? this.parseSelectionSet()\r\n        : undefined,\r\n    });\r\n  }\r\n  /**\r\n   * Arguments[Const] : ( Argument[?Const]+ )\r\n   */\r\n\r\n  parseArguments(isConst) {\r\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\r\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\r\n  }\r\n  /**\r\n   * Argument[Const] : Name : Value[?Const]\r\n   */\r\n\r\n  parseArgument(isConst = false) {\r\n    const start = this._lexer.token;\r\n    const name = this.parseName();\r\n    this.expectToken(TokenKind.COLON);\r\n    return this.node(start, {\r\n      kind: Kind.ARGUMENT,\r\n      name,\r\n      value: this.parseValueLiteral(isConst),\r\n    });\r\n  }\r\n\r\n  parseConstArgument() {\r\n    return this.parseArgument(true);\r\n  } // Implements the parsing rules in the Fragments section.\r\n\r\n  /**\r\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\r\n   *\r\n   * FragmentSpread : ... FragmentName Directives?\r\n   *\r\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\r\n   */\r\n\r\n  parseFragment() {\r\n    const start = this._lexer.token;\r\n    this.expectToken(TokenKind.SPREAD);\r\n    const hasTypeCondition = this.expectOptionalKeyword('on');\r\n\r\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\r\n      return this.node(start, {\r\n        kind: Kind.FRAGMENT_SPREAD,\r\n        name: this.parseFragmentName(),\r\n        directives: this.parseDirectives(false),\r\n      });\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.INLINE_FRAGMENT,\r\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\r\n      directives: this.parseDirectives(false),\r\n      selectionSet: this.parseSelectionSet(),\r\n    });\r\n  }\r\n  /**\r\n   * FragmentDefinition :\r\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\r\n   *\r\n   * TypeCondition : NamedType\r\n   */\r\n\r\n  parseFragmentDefinition() {\r\n    var _this$_options;\r\n\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\r\n    // the grammar of FragmentDefinition:\r\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\r\n\r\n    if (\r\n      ((_this$_options = this._options) === null || _this$_options === void 0\r\n        ? void 0\r\n        : _this$_options.allowLegacyFragmentVariables) === true\r\n    ) {\r\n      return this.node(start, {\r\n        kind: Kind.FRAGMENT_DEFINITION,\r\n        name: this.parseFragmentName(),\r\n        variableDefinitions: this.parseVariableDefinitions(),\r\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\r\n        directives: this.parseDirectives(false),\r\n        selectionSet: this.parseSelectionSet(),\r\n      });\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.FRAGMENT_DEFINITION,\r\n      name: this.parseFragmentName(),\r\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\r\n      directives: this.parseDirectives(false),\r\n      selectionSet: this.parseSelectionSet(),\r\n    });\r\n  }\r\n  /**\r\n   * FragmentName : Name but not `on`\r\n   */\r\n\r\n  parseFragmentName() {\r\n    if (this._lexer.token.value === 'on') {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.parseName();\r\n  } // Implements the parsing rules in the Values section.\r\n\r\n  /**\r\n   * Value[Const] :\r\n   *   - [~Const] Variable\r\n   *   - IntValue\r\n   *   - FloatValue\r\n   *   - StringValue\r\n   *   - BooleanValue\r\n   *   - NullValue\r\n   *   - EnumValue\r\n   *   - ListValue[?Const]\r\n   *   - ObjectValue[?Const]\r\n   *\r\n   * BooleanValue : one of `true` `false`\r\n   *\r\n   * NullValue : `null`\r\n   *\r\n   * EnumValue : Name but not `true`, `false` or `null`\r\n   */\r\n\r\n  parseValueLiteral(isConst) {\r\n    const token = this._lexer.token;\r\n\r\n    switch (token.kind) {\r\n      case TokenKind.BRACKET_L:\r\n        return this.parseList(isConst);\r\n\r\n      case TokenKind.BRACE_L:\r\n        return this.parseObject(isConst);\r\n\r\n      case TokenKind.INT:\r\n        this._lexer.advance();\r\n\r\n        return this.node(token, {\r\n          kind: Kind.INT,\r\n          value: token.value,\r\n        });\r\n\r\n      case TokenKind.FLOAT:\r\n        this._lexer.advance();\r\n\r\n        return this.node(token, {\r\n          kind: Kind.FLOAT,\r\n          value: token.value,\r\n        });\r\n\r\n      case TokenKind.STRING:\r\n      case TokenKind.BLOCK_STRING:\r\n        return this.parseStringLiteral();\r\n\r\n      case TokenKind.NAME:\r\n        this._lexer.advance();\r\n\r\n        switch (token.value) {\r\n          case 'true':\r\n            return this.node(token, {\r\n              kind: Kind.BOOLEAN,\r\n              value: true,\r\n            });\r\n\r\n          case 'false':\r\n            return this.node(token, {\r\n              kind: Kind.BOOLEAN,\r\n              value: false,\r\n            });\r\n\r\n          case 'null':\r\n            return this.node(token, {\r\n              kind: Kind.NULL,\r\n            });\r\n\r\n          default:\r\n            return this.node(token, {\r\n              kind: Kind.ENUM,\r\n              value: token.value,\r\n            });\r\n        }\r\n\r\n      case TokenKind.DOLLAR:\r\n        if (isConst) {\r\n          this.expectToken(TokenKind.DOLLAR);\r\n\r\n          if (this._lexer.token.kind === TokenKind.NAME) {\r\n            const varName = this._lexer.token.value;\r\n            throw syntaxError(\r\n              this._lexer.source,\r\n              token.start,\r\n              `Unexpected variable \"$${varName}\" in constant value.`,\r\n            );\r\n          } else {\r\n            throw this.unexpected(token);\r\n          }\r\n        }\r\n\r\n        return this.parseVariable();\r\n\r\n      default:\r\n        throw this.unexpected();\r\n    }\r\n  }\r\n\r\n  parseConstValueLiteral() {\r\n    return this.parseValueLiteral(true);\r\n  }\r\n\r\n  parseStringLiteral() {\r\n    const token = this._lexer.token;\r\n\r\n    this._lexer.advance();\r\n\r\n    return this.node(token, {\r\n      kind: Kind.STRING,\r\n      value: token.value,\r\n      block: token.kind === TokenKind.BLOCK_STRING,\r\n    });\r\n  }\r\n  /**\r\n   * ListValue[Const] :\r\n   *   - [ ]\r\n   *   - [ Value[?Const]+ ]\r\n   */\r\n\r\n  parseList(isConst) {\r\n    const item = () => this.parseValueLiteral(isConst);\r\n\r\n    return this.node(this._lexer.token, {\r\n      kind: Kind.LIST,\r\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\r\n    });\r\n  }\r\n  /**\r\n   * ```\r\n   * ObjectValue[Const] :\r\n   *   - { }\r\n   *   - { ObjectField[?Const]+ }\r\n   * ```\r\n   */\r\n\r\n  parseObject(isConst) {\r\n    const item = () => this.parseObjectField(isConst);\r\n\r\n    return this.node(this._lexer.token, {\r\n      kind: Kind.OBJECT,\r\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\r\n    });\r\n  }\r\n  /**\r\n   * ObjectField[Const] : Name : Value[?Const]\r\n   */\r\n\r\n  parseObjectField(isConst) {\r\n    const start = this._lexer.token;\r\n    const name = this.parseName();\r\n    this.expectToken(TokenKind.COLON);\r\n    return this.node(start, {\r\n      kind: Kind.OBJECT_FIELD,\r\n      name,\r\n      value: this.parseValueLiteral(isConst),\r\n    });\r\n  } // Implements the parsing rules in the Directives section.\r\n\r\n  /**\r\n   * Directives[Const] : Directive[?Const]+\r\n   */\r\n\r\n  parseDirectives(isConst) {\r\n    const directives = [];\r\n\r\n    while (this.peek(TokenKind.AT)) {\r\n      directives.push(this.parseDirective(isConst));\r\n    }\r\n\r\n    return directives;\r\n  }\r\n\r\n  parseConstDirectives() {\r\n    return this.parseDirectives(true);\r\n  }\r\n  /**\r\n   * ```\r\n   * Directive[Const] : @ Name Arguments[?Const]?\r\n   * ```\r\n   */\r\n\r\n  parseDirective(isConst) {\r\n    const start = this._lexer.token;\r\n    this.expectToken(TokenKind.AT);\r\n    return this.node(start, {\r\n      kind: Kind.DIRECTIVE,\r\n      name: this.parseName(),\r\n      arguments: this.parseArguments(isConst),\r\n    });\r\n  } // Implements the parsing rules in the Types section.\r\n\r\n  /**\r\n   * Type :\r\n   *   - NamedType\r\n   *   - ListType\r\n   *   - NonNullType\r\n   */\r\n\r\n  parseTypeReference() {\r\n    const start = this._lexer.token;\r\n    let type;\r\n\r\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\r\n      const innerType = this.parseTypeReference();\r\n      this.expectToken(TokenKind.BRACKET_R);\r\n      type = this.node(start, {\r\n        kind: Kind.LIST_TYPE,\r\n        type: innerType,\r\n      });\r\n    } else {\r\n      type = this.parseNamedType();\r\n    }\r\n\r\n    if (this.expectOptionalToken(TokenKind.BANG)) {\r\n      return this.node(start, {\r\n        kind: Kind.NON_NULL_TYPE,\r\n        type,\r\n      });\r\n    }\r\n\r\n    return type;\r\n  }\r\n  /**\r\n   * NamedType : Name\r\n   */\r\n\r\n  parseNamedType() {\r\n    return this.node(this._lexer.token, {\r\n      kind: Kind.NAMED_TYPE,\r\n      name: this.parseName(),\r\n    });\r\n  } // Implements the parsing rules in the Type Definition section.\r\n\r\n  peekDescription() {\r\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\r\n  }\r\n  /**\r\n   * Description : StringValue\r\n   */\r\n\r\n  parseDescription() {\r\n    if (this.peekDescription()) {\r\n      return this.parseStringLiteral();\r\n    }\r\n  }\r\n  /**\r\n   * ```\r\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\r\n   * ```\r\n   */\r\n\r\n  parseSchemaDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('schema');\r\n    const directives = this.parseConstDirectives();\r\n    const operationTypes = this.many(\r\n      TokenKind.BRACE_L,\r\n      this.parseOperationTypeDefinition,\r\n      TokenKind.BRACE_R,\r\n    );\r\n    return this.node(start, {\r\n      kind: Kind.SCHEMA_DEFINITION,\r\n      description,\r\n      directives,\r\n      operationTypes,\r\n    });\r\n  }\r\n  /**\r\n   * OperationTypeDefinition : OperationType : NamedType\r\n   */\r\n\r\n  parseOperationTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const operation = this.parseOperationType();\r\n    this.expectToken(TokenKind.COLON);\r\n    const type = this.parseNamedType();\r\n    return this.node(start, {\r\n      kind: Kind.OPERATION_TYPE_DEFINITION,\r\n      operation,\r\n      type,\r\n    });\r\n  }\r\n  /**\r\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\r\n   */\r\n\r\n  parseScalarTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('scalar');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    return this.node(start, {\r\n      kind: Kind.SCALAR_TYPE_DEFINITION,\r\n      description,\r\n      name,\r\n      directives,\r\n    });\r\n  }\r\n  /**\r\n   * ObjectTypeDefinition :\r\n   *   Description?\r\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\r\n   */\r\n\r\n  parseObjectTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('type');\r\n    const name = this.parseName();\r\n    const interfaces = this.parseImplementsInterfaces();\r\n    const directives = this.parseConstDirectives();\r\n    const fields = this.parseFieldsDefinition();\r\n    return this.node(start, {\r\n      kind: Kind.OBJECT_TYPE_DEFINITION,\r\n      description,\r\n      name,\r\n      interfaces,\r\n      directives,\r\n      fields,\r\n    });\r\n  }\r\n  /**\r\n   * ImplementsInterfaces :\r\n   *   - implements `&`? NamedType\r\n   *   - ImplementsInterfaces & NamedType\r\n   */\r\n\r\n  parseImplementsInterfaces() {\r\n    return this.expectOptionalKeyword('implements')\r\n      ? this.delimitedMany(TokenKind.AMP, this.parseNamedType)\r\n      : [];\r\n  }\r\n  /**\r\n   * ```\r\n   * FieldsDefinition : { FieldDefinition+ }\r\n   * ```\r\n   */\r\n\r\n  parseFieldsDefinition() {\r\n    return this.optionalMany(\r\n      TokenKind.BRACE_L,\r\n      this.parseFieldDefinition,\r\n      TokenKind.BRACE_R,\r\n    );\r\n  }\r\n  /**\r\n   * FieldDefinition :\r\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\r\n   */\r\n\r\n  parseFieldDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    const name = this.parseName();\r\n    const args = this.parseArgumentDefs();\r\n    this.expectToken(TokenKind.COLON);\r\n    const type = this.parseTypeReference();\r\n    const directives = this.parseConstDirectives();\r\n    return this.node(start, {\r\n      kind: Kind.FIELD_DEFINITION,\r\n      description,\r\n      name,\r\n      arguments: args,\r\n      type,\r\n      directives,\r\n    });\r\n  }\r\n  /**\r\n   * ArgumentsDefinition : ( InputValueDefinition+ )\r\n   */\r\n\r\n  parseArgumentDefs() {\r\n    return this.optionalMany(\r\n      TokenKind.PAREN_L,\r\n      this.parseInputValueDef,\r\n      TokenKind.PAREN_R,\r\n    );\r\n  }\r\n  /**\r\n   * InputValueDefinition :\r\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\r\n   */\r\n\r\n  parseInputValueDef() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    const name = this.parseName();\r\n    this.expectToken(TokenKind.COLON);\r\n    const type = this.parseTypeReference();\r\n    let defaultValue;\r\n\r\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\r\n      defaultValue = this.parseConstValueLiteral();\r\n    }\r\n\r\n    const directives = this.parseConstDirectives();\r\n    return this.node(start, {\r\n      kind: Kind.INPUT_VALUE_DEFINITION,\r\n      description,\r\n      name,\r\n      type,\r\n      defaultValue,\r\n      directives,\r\n    });\r\n  }\r\n  /**\r\n   * InterfaceTypeDefinition :\r\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\r\n   */\r\n\r\n  parseInterfaceTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('interface');\r\n    const name = this.parseName();\r\n    const interfaces = this.parseImplementsInterfaces();\r\n    const directives = this.parseConstDirectives();\r\n    const fields = this.parseFieldsDefinition();\r\n    return this.node(start, {\r\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\r\n      description,\r\n      name,\r\n      interfaces,\r\n      directives,\r\n      fields,\r\n    });\r\n  }\r\n  /**\r\n   * UnionTypeDefinition :\r\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\r\n   */\r\n\r\n  parseUnionTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('union');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    const types = this.parseUnionMemberTypes();\r\n    return this.node(start, {\r\n      kind: Kind.UNION_TYPE_DEFINITION,\r\n      description,\r\n      name,\r\n      directives,\r\n      types,\r\n    });\r\n  }\r\n  /**\r\n   * UnionMemberTypes :\r\n   *   - = `|`? NamedType\r\n   *   - UnionMemberTypes | NamedType\r\n   */\r\n\r\n  parseUnionMemberTypes() {\r\n    return this.expectOptionalToken(TokenKind.EQUALS)\r\n      ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType)\r\n      : [];\r\n  }\r\n  /**\r\n   * EnumTypeDefinition :\r\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\r\n   */\r\n\r\n  parseEnumTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('enum');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    const values = this.parseEnumValuesDefinition();\r\n    return this.node(start, {\r\n      kind: Kind.ENUM_TYPE_DEFINITION,\r\n      description,\r\n      name,\r\n      directives,\r\n      values,\r\n    });\r\n  }\r\n  /**\r\n   * ```\r\n   * EnumValuesDefinition : { EnumValueDefinition+ }\r\n   * ```\r\n   */\r\n\r\n  parseEnumValuesDefinition() {\r\n    return this.optionalMany(\r\n      TokenKind.BRACE_L,\r\n      this.parseEnumValueDefinition,\r\n      TokenKind.BRACE_R,\r\n    );\r\n  }\r\n  /**\r\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\r\n   */\r\n\r\n  parseEnumValueDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    const name = this.parseEnumValueName();\r\n    const directives = this.parseConstDirectives();\r\n    return this.node(start, {\r\n      kind: Kind.ENUM_VALUE_DEFINITION,\r\n      description,\r\n      name,\r\n      directives,\r\n    });\r\n  }\r\n  /**\r\n   * EnumValue : Name but not `true`, `false` or `null`\r\n   */\r\n\r\n  parseEnumValueName() {\r\n    if (\r\n      this._lexer.token.value === 'true' ||\r\n      this._lexer.token.value === 'false' ||\r\n      this._lexer.token.value === 'null'\r\n    ) {\r\n      throw syntaxError(\r\n        this._lexer.source,\r\n        this._lexer.token.start,\r\n        `${getTokenDesc(\r\n          this._lexer.token,\r\n        )} is reserved and cannot be used for an enum value.`,\r\n      );\r\n    }\r\n\r\n    return this.parseName();\r\n  }\r\n  /**\r\n   * InputObjectTypeDefinition :\r\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\r\n   */\r\n\r\n  parseInputObjectTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('input');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    const fields = this.parseInputFieldsDefinition();\r\n    return this.node(start, {\r\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\r\n      description,\r\n      name,\r\n      directives,\r\n      fields,\r\n    });\r\n  }\r\n  /**\r\n   * ```\r\n   * InputFieldsDefinition : { InputValueDefinition+ }\r\n   * ```\r\n   */\r\n\r\n  parseInputFieldsDefinition() {\r\n    return this.optionalMany(\r\n      TokenKind.BRACE_L,\r\n      this.parseInputValueDef,\r\n      TokenKind.BRACE_R,\r\n    );\r\n  }\r\n  /**\r\n   * TypeSystemExtension :\r\n   *   - SchemaExtension\r\n   *   - TypeExtension\r\n   *\r\n   * TypeExtension :\r\n   *   - ScalarTypeExtension\r\n   *   - ObjectTypeExtension\r\n   *   - InterfaceTypeExtension\r\n   *   - UnionTypeExtension\r\n   *   - EnumTypeExtension\r\n   *   - InputObjectTypeDefinition\r\n   */\r\n\r\n  parseTypeSystemExtension() {\r\n    const keywordToken = this._lexer.lookahead();\r\n\r\n    if (keywordToken.kind === TokenKind.NAME) {\r\n      switch (keywordToken.value) {\r\n        case 'schema':\r\n          return this.parseSchemaExtension();\r\n\r\n        case 'scalar':\r\n          return this.parseScalarTypeExtension();\r\n\r\n        case 'type':\r\n          return this.parseObjectTypeExtension();\r\n\r\n        case 'interface':\r\n          return this.parseInterfaceTypeExtension();\r\n\r\n        case 'union':\r\n          return this.parseUnionTypeExtension();\r\n\r\n        case 'enum':\r\n          return this.parseEnumTypeExtension();\r\n\r\n        case 'input':\r\n          return this.parseInputObjectTypeExtension();\r\n      }\r\n    }\r\n\r\n    throw this.unexpected(keywordToken);\r\n  }\r\n  /**\r\n   * ```\r\n   * SchemaExtension :\r\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\r\n   *  - extend schema Directives[Const]\r\n   * ```\r\n   */\r\n\r\n  parseSchemaExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('schema');\r\n    const directives = this.parseConstDirectives();\r\n    const operationTypes = this.optionalMany(\r\n      TokenKind.BRACE_L,\r\n      this.parseOperationTypeDefinition,\r\n      TokenKind.BRACE_R,\r\n    );\r\n\r\n    if (directives.length === 0 && operationTypes.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.SCHEMA_EXTENSION,\r\n      directives,\r\n      operationTypes,\r\n    });\r\n  }\r\n  /**\r\n   * ScalarTypeExtension :\r\n   *   - extend scalar Name Directives[Const]\r\n   */\r\n\r\n  parseScalarTypeExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('scalar');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n\r\n    if (directives.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.SCALAR_TYPE_EXTENSION,\r\n      name,\r\n      directives,\r\n    });\r\n  }\r\n  /**\r\n   * ObjectTypeExtension :\r\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\r\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\r\n   *  - extend type Name ImplementsInterfaces\r\n   */\r\n\r\n  parseObjectTypeExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('type');\r\n    const name = this.parseName();\r\n    const interfaces = this.parseImplementsInterfaces();\r\n    const directives = this.parseConstDirectives();\r\n    const fields = this.parseFieldsDefinition();\r\n\r\n    if (\r\n      interfaces.length === 0 &&\r\n      directives.length === 0 &&\r\n      fields.length === 0\r\n    ) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.OBJECT_TYPE_EXTENSION,\r\n      name,\r\n      interfaces,\r\n      directives,\r\n      fields,\r\n    });\r\n  }\r\n  /**\r\n   * InterfaceTypeExtension :\r\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\r\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\r\n   *  - extend interface Name ImplementsInterfaces\r\n   */\r\n\r\n  parseInterfaceTypeExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('interface');\r\n    const name = this.parseName();\r\n    const interfaces = this.parseImplementsInterfaces();\r\n    const directives = this.parseConstDirectives();\r\n    const fields = this.parseFieldsDefinition();\r\n\r\n    if (\r\n      interfaces.length === 0 &&\r\n      directives.length === 0 &&\r\n      fields.length === 0\r\n    ) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\r\n      name,\r\n      interfaces,\r\n      directives,\r\n      fields,\r\n    });\r\n  }\r\n  /**\r\n   * UnionTypeExtension :\r\n   *   - extend union Name Directives[Const]? UnionMemberTypes\r\n   *   - extend union Name Directives[Const]\r\n   */\r\n\r\n  parseUnionTypeExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('union');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    const types = this.parseUnionMemberTypes();\r\n\r\n    if (directives.length === 0 && types.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.UNION_TYPE_EXTENSION,\r\n      name,\r\n      directives,\r\n      types,\r\n    });\r\n  }\r\n  /**\r\n   * EnumTypeExtension :\r\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\r\n   *   - extend enum Name Directives[Const]\r\n   */\r\n\r\n  parseEnumTypeExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('enum');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    const values = this.parseEnumValuesDefinition();\r\n\r\n    if (directives.length === 0 && values.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.ENUM_TYPE_EXTENSION,\r\n      name,\r\n      directives,\r\n      values,\r\n    });\r\n  }\r\n  /**\r\n   * InputObjectTypeExtension :\r\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\r\n   *   - extend input Name Directives[Const]\r\n   */\r\n\r\n  parseInputObjectTypeExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('input');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    const fields = this.parseInputFieldsDefinition();\r\n\r\n    if (directives.length === 0 && fields.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\r\n      name,\r\n      directives,\r\n      fields,\r\n    });\r\n  }\r\n  /**\r\n   * ```\r\n   * DirectiveDefinition :\r\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\r\n   * ```\r\n   */\r\n\r\n  parseDirectiveDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('directive');\r\n    this.expectToken(TokenKind.AT);\r\n    const name = this.parseName();\r\n    const args = this.parseArgumentDefs();\r\n    const repeatable = this.expectOptionalKeyword('repeatable');\r\n    this.expectKeyword('on');\r\n    const locations = this.parseDirectiveLocations();\r\n    return this.node(start, {\r\n      kind: Kind.DIRECTIVE_DEFINITION,\r\n      description,\r\n      name,\r\n      arguments: args,\r\n      repeatable,\r\n      locations,\r\n    });\r\n  }\r\n  /**\r\n   * DirectiveLocations :\r\n   *   - `|`? DirectiveLocation\r\n   *   - DirectiveLocations | DirectiveLocation\r\n   */\r\n\r\n  parseDirectiveLocations() {\r\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\r\n  }\r\n  /*\r\n   * DirectiveLocation :\r\n   *   - ExecutableDirectiveLocation\r\n   *   - TypeSystemDirectiveLocation\r\n   *\r\n   * ExecutableDirectiveLocation : one of\r\n   *   `QUERY`\r\n   *   `MUTATION`\r\n   *   `SUBSCRIPTION`\r\n   *   `FIELD`\r\n   *   `FRAGMENT_DEFINITION`\r\n   *   `FRAGMENT_SPREAD`\r\n   *   `INLINE_FRAGMENT`\r\n   *\r\n   * TypeSystemDirectiveLocation : one of\r\n   *   `SCHEMA`\r\n   *   `SCALAR`\r\n   *   `OBJECT`\r\n   *   `FIELD_DEFINITION`\r\n   *   `ARGUMENT_DEFINITION`\r\n   *   `INTERFACE`\r\n   *   `UNION`\r\n   *   `ENUM`\r\n   *   `ENUM_VALUE`\r\n   *   `INPUT_OBJECT`\r\n   *   `INPUT_FIELD_DEFINITION`\r\n   */\r\n\r\n  parseDirectiveLocation() {\r\n    const start = this._lexer.token;\r\n    const name = this.parseName();\r\n\r\n    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\r\n      return name;\r\n    }\r\n\r\n    throw this.unexpected(start);\r\n  } // Core parsing utility functions\r\n\r\n  /**\r\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\r\n   * location object, used to identify the place in the source that created a\r\n   * given parsed object.\r\n   */\r\n\r\n  node(startToken, node) {\r\n    var _this$_options2;\r\n\r\n    if (\r\n      ((_this$_options2 = this._options) === null || _this$_options2 === void 0\r\n        ? void 0\r\n        : _this$_options2.noLocation) !== true\r\n    ) {\r\n      node.loc = new Location(\r\n        startToken,\r\n        this._lexer.lastToken,\r\n        this._lexer.source,\r\n      );\r\n    }\r\n\r\n    return node;\r\n  }\r\n  /**\r\n   * Determines if the next token is of a given kind\r\n   */\r\n\r\n  peek(kind) {\r\n    return this._lexer.token.kind === kind;\r\n  }\r\n  /**\r\n   * If the next token is of the given kind, return that token after advancing the lexer.\r\n   * Otherwise, do not change the parser state and throw an error.\r\n   */\r\n\r\n  expectToken(kind) {\r\n    const token = this._lexer.token;\r\n\r\n    if (token.kind === kind) {\r\n      this._lexer.advance();\r\n\r\n      return token;\r\n    }\r\n\r\n    throw syntaxError(\r\n      this._lexer.source,\r\n      token.start,\r\n      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,\r\n    );\r\n  }\r\n  /**\r\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\r\n   * Otherwise, do not change the parser state and return \"false\".\r\n   */\r\n\r\n  expectOptionalToken(kind) {\r\n    const token = this._lexer.token;\r\n\r\n    if (token.kind === kind) {\r\n      this._lexer.advance();\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n  /**\r\n   * If the next token is a given keyword, advance the lexer.\r\n   * Otherwise, do not change the parser state and throw an error.\r\n   */\r\n\r\n  expectKeyword(value) {\r\n    const token = this._lexer.token;\r\n\r\n    if (token.kind === TokenKind.NAME && token.value === value) {\r\n      this._lexer.advance();\r\n    } else {\r\n      throw syntaxError(\r\n        this._lexer.source,\r\n        token.start,\r\n        `Expected \"${value}\", found ${getTokenDesc(token)}.`,\r\n      );\r\n    }\r\n  }\r\n  /**\r\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\r\n   * Otherwise, do not change the parser state and return \"false\".\r\n   */\r\n\r\n  expectOptionalKeyword(value) {\r\n    const token = this._lexer.token;\r\n\r\n    if (token.kind === TokenKind.NAME && token.value === value) {\r\n      this._lexer.advance();\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n  /**\r\n   * Helper function for creating an error when an unexpected lexed token is encountered.\r\n   */\r\n\r\n  unexpected(atToken) {\r\n    const token =\r\n      atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\r\n    return syntaxError(\r\n      this._lexer.source,\r\n      token.start,\r\n      `Unexpected ${getTokenDesc(token)}.`,\r\n    );\r\n  }\r\n  /**\r\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\r\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\r\n\r\n  any(openKind, parseFn, closeKind) {\r\n    this.expectToken(openKind);\r\n    const nodes = [];\r\n\r\n    while (!this.expectOptionalToken(closeKind)) {\r\n      nodes.push(parseFn.call(this));\r\n    }\r\n\r\n    return nodes;\r\n  }\r\n  /**\r\n   * Returns a list of parse nodes, determined by the parseFn.\r\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\r\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\r\n\r\n  optionalMany(openKind, parseFn, closeKind) {\r\n    if (this.expectOptionalToken(openKind)) {\r\n      const nodes = [];\r\n\r\n      do {\r\n        nodes.push(parseFn.call(this));\r\n      } while (!this.expectOptionalToken(closeKind));\r\n\r\n      return nodes;\r\n    }\r\n\r\n    return [];\r\n  }\r\n  /**\r\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\r\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\r\n\r\n  many(openKind, parseFn, closeKind) {\r\n    this.expectToken(openKind);\r\n    const nodes = [];\r\n\r\n    do {\r\n      nodes.push(parseFn.call(this));\r\n    } while (!this.expectOptionalToken(closeKind));\r\n\r\n    return nodes;\r\n  }\r\n  /**\r\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\r\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\r\n   * Advances the parser to the next lex token after last item in the list.\r\n   */\r\n\r\n  delimitedMany(delimiterKind, parseFn) {\r\n    this.expectOptionalToken(delimiterKind);\r\n    const nodes = [];\r\n\r\n    do {\r\n      nodes.push(parseFn.call(this));\r\n    } while (this.expectOptionalToken(delimiterKind));\r\n\r\n    return nodes;\r\n  }\r\n}\r\n/**\r\n * A helper function to describe a token as a string for debugging.\r\n */\r\n\r\nfunction getTokenDesc(token) {\r\n  const value = token.value;\r\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\r\n}\r\n/**\r\n * A helper function to describe a token kind as a string for debugging.\r\n */\r\n\r\nfunction getTokenKindDesc(kind) {\r\n  return isPunctuatorTokenKind(kind) ? `\"${kind}\"` : kind;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}