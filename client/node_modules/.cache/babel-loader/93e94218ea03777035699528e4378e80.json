{"ast":null,"code":"import { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isTypeDefinitionNode } from '../../language/predicates.mjs';\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType } from '../../type/definition.mjs';\n/**\r\n * Possible type extension\r\n *\r\n * A type extension is only valid if the type is defined and has the same kind.\r\n */\n\nexport function PossibleTypeExtensionsRule(context) {\n  const schema = context.getSchema();\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension\n  };\n\n  function checkExtension(node) {\n    const typeName = node.name.value;\n    const defNode = definedTypes[typeName];\n    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    let expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        const kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(new GraphQLError(`Cannot extend non-${kindStr} type \"${typeName}\".`, defNode ? [defNode, node] : node));\n      }\n    } else {\n      const allTypeNames = Object.keys({ ...definedTypes,\n        ...(schema === null || schema === void 0 ? void 0 : schema.getTypeMap())\n      });\n      const suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(new GraphQLError(`Cannot extend type \"${typeName}\" because it is not defined.` + didYouMean(suggestedTypes), node.name));\n    }\n  }\n}\nconst defKindToExtKind = {\n  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,\n  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,\n  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,\n  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,\n  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,\n  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION\n};\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  }\n\n  if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable. All possible types have been considered\n\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n    // Not reachable. All possible types have been considered\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(kind));\n  }\n}","map":{"version":3,"sources":["C:/BootCamp/Book-Search-21/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs"],"names":["inspect","invariant","didYouMean","suggestionList","GraphQLError","Kind","isTypeDefinitionNode","isScalarType","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","PossibleTypeExtensionsRule","context","schema","getSchema","definedTypes","Object","create","def","getDocument","definitions","name","value","ScalarTypeExtension","checkExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","node","typeName","defNode","existingType","getType","expectedKind","defKindToExtKind","kind","typeToExtKind","kindStr","extensionKindToTypeName","reportError","allTypeNames","keys","getTypeMap","suggestedTypes","SCALAR_TYPE_DEFINITION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_DEFINITION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_DEFINITION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_DEFINITION","UNION_TYPE_EXTENSION","ENUM_TYPE_DEFINITION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_DEFINITION","INPUT_OBJECT_TYPE_EXTENSION","type"],"mappings":"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","sourcesContent":["import { inspect } from '../../jsutils/inspect.mjs';\r\nimport { invariant } from '../../jsutils/invariant.mjs';\r\nimport { didYouMean } from '../../jsutils/didYouMean.mjs';\r\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\r\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\r\nimport { Kind } from '../../language/kinds.mjs';\r\nimport { isTypeDefinitionNode } from '../../language/predicates.mjs';\r\nimport {\r\n  isScalarType,\r\n  isObjectType,\r\n  isInterfaceType,\r\n  isUnionType,\r\n  isEnumType,\r\n  isInputObjectType,\r\n} from '../../type/definition.mjs';\r\n\r\n/**\r\n * Possible type extension\r\n *\r\n * A type extension is only valid if the type is defined and has the same kind.\r\n */\r\nexport function PossibleTypeExtensionsRule(context) {\r\n  const schema = context.getSchema();\r\n  const definedTypes = Object.create(null);\r\n\r\n  for (const def of context.getDocument().definitions) {\r\n    if (isTypeDefinitionNode(def)) {\r\n      definedTypes[def.name.value] = def;\r\n    }\r\n  }\r\n\r\n  return {\r\n    ScalarTypeExtension: checkExtension,\r\n    ObjectTypeExtension: checkExtension,\r\n    InterfaceTypeExtension: checkExtension,\r\n    UnionTypeExtension: checkExtension,\r\n    EnumTypeExtension: checkExtension,\r\n    InputObjectTypeExtension: checkExtension,\r\n  };\r\n\r\n  function checkExtension(node) {\r\n    const typeName = node.name.value;\r\n    const defNode = definedTypes[typeName];\r\n    const existingType =\r\n      schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\r\n    let expectedKind;\r\n\r\n    if (defNode) {\r\n      expectedKind = defKindToExtKind[defNode.kind];\r\n    } else if (existingType) {\r\n      expectedKind = typeToExtKind(existingType);\r\n    }\r\n\r\n    if (expectedKind) {\r\n      if (expectedKind !== node.kind) {\r\n        const kindStr = extensionKindToTypeName(node.kind);\r\n        context.reportError(\r\n          new GraphQLError(\r\n            `Cannot extend non-${kindStr} type \"${typeName}\".`,\r\n            defNode ? [defNode, node] : node,\r\n          ),\r\n        );\r\n      }\r\n    } else {\r\n      const allTypeNames = Object.keys({\r\n        ...definedTypes,\r\n        ...(schema === null || schema === void 0\r\n          ? void 0\r\n          : schema.getTypeMap()),\r\n      });\r\n      const suggestedTypes = suggestionList(typeName, allTypeNames);\r\n      context.reportError(\r\n        new GraphQLError(\r\n          `Cannot extend type \"${typeName}\" because it is not defined.` +\r\n            didYouMean(suggestedTypes),\r\n          node.name,\r\n        ),\r\n      );\r\n    }\r\n  }\r\n}\r\nconst defKindToExtKind = {\r\n  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,\r\n  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,\r\n  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,\r\n  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,\r\n  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,\r\n  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION,\r\n};\r\n\r\nfunction typeToExtKind(type) {\r\n  if (isScalarType(type)) {\r\n    return Kind.SCALAR_TYPE_EXTENSION;\r\n  }\r\n\r\n  if (isObjectType(type)) {\r\n    return Kind.OBJECT_TYPE_EXTENSION;\r\n  }\r\n\r\n  if (isInterfaceType(type)) {\r\n    return Kind.INTERFACE_TYPE_EXTENSION;\r\n  }\r\n\r\n  if (isUnionType(type)) {\r\n    return Kind.UNION_TYPE_EXTENSION;\r\n  }\r\n\r\n  if (isEnumType(type)) {\r\n    return Kind.ENUM_TYPE_EXTENSION;\r\n  }\r\n\r\n  if (isInputObjectType(type)) {\r\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\r\n  }\r\n  /* c8 ignore next 3 */\r\n  // Not reachable. All possible types have been considered\r\n\r\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\r\n}\r\n\r\nfunction extensionKindToTypeName(kind) {\r\n  switch (kind) {\r\n    case Kind.SCALAR_TYPE_EXTENSION:\r\n      return 'scalar';\r\n\r\n    case Kind.OBJECT_TYPE_EXTENSION:\r\n      return 'object';\r\n\r\n    case Kind.INTERFACE_TYPE_EXTENSION:\r\n      return 'interface';\r\n\r\n    case Kind.UNION_TYPE_EXTENSION:\r\n      return 'union';\r\n\r\n    case Kind.ENUM_TYPE_EXTENSION:\r\n      return 'enum';\r\n\r\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\r\n      return 'input object';\r\n    // Not reachable. All possible types have been considered\r\n\r\n    /* c8 ignore next */\r\n\r\n    default:\r\n      false || invariant(false, 'Unexpected kind: ' + inspect(kind));\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}