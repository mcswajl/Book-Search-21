{"ast":null,"code":"import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { isIterableObject } from '../jsutils/isIterableObject.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { GraphQLID } from '../type/scalars.mjs';\nimport { isLeafType, isEnumType, isInputObjectType, isListType, isNonNullType } from '../type/definition.mjs';\n/**\r\n * Produces a GraphQL Value AST given a JavaScript object.\r\n * Function will match JavaScript/JSON values to GraphQL AST schema format\r\n * by using suggested GraphQLInputType. For example:\r\n *\r\n *     astFromValue(\"value\", GraphQLString)\r\n *\r\n * A GraphQL type must be provided, which will be used to interpret different\r\n * JavaScript values.\r\n *\r\n * | JSON Value    | GraphQL Value        |\r\n * | ------------- | -------------------- |\r\n * | Object        | Input Object         |\r\n * | Array         | List                 |\r\n * | Boolean       | Boolean              |\r\n * | String        | String / Enum Value  |\r\n * | Number        | Int / Float          |\r\n * | Unknown       | Enum Value           |\r\n * | null          | NullValue            |\r\n *\r\n */\n\nexport function astFromValue(value, type) {\n  if (isNonNullType(type)) {\n    const astValue = astFromValue(value, type.ofType);\n\n    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {\n      return null;\n    }\n\n    return astValue;\n  } // only explicit null, not undefined, NaN\n\n\n  if (value === null) {\n    return {\n      kind: Kind.NULL\n    };\n  } // undefined\n\n\n  if (value === undefined) {\n    return null;\n  } // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n  // the value is not an array, convert the value using the list's item type.\n\n\n  if (isListType(type)) {\n    const itemType = type.ofType;\n\n    if (isIterableObject(value)) {\n      const valuesNodes = [];\n\n      for (const item of value) {\n        const itemNode = astFromValue(item, itemType);\n\n        if (itemNode != null) {\n          valuesNodes.push(itemNode);\n        }\n      }\n\n      return {\n        kind: Kind.LIST,\n        values: valuesNodes\n      };\n    }\n\n    return astFromValue(value, itemType);\n  } // Populate the fields of the input object by creating ASTs from each value\n  // in the JavaScript object according to the fields in the input type.\n\n\n  if (isInputObjectType(type)) {\n    if (!isObjectLike(value)) {\n      return null;\n    }\n\n    const fieldNodes = [];\n\n    for (const field of Object.values(type.getFields())) {\n      const fieldValue = astFromValue(value[field.name], field.type);\n\n      if (fieldValue) {\n        fieldNodes.push({\n          kind: Kind.OBJECT_FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: field.name\n          },\n          value: fieldValue\n        });\n      }\n    }\n\n    return {\n      kind: Kind.OBJECT,\n      fields: fieldNodes\n    };\n  }\n\n  if (isLeafType(type)) {\n    // Since value is an internally represented value, it must be serialized\n    // to an externally represented value before converting into an AST.\n    const serialized = type.serialize(value);\n\n    if (serialized == null) {\n      return null;\n    } // Others serialize based on their corresponding JavaScript scalar types.\n\n\n    if (typeof serialized === 'boolean') {\n      return {\n        kind: Kind.BOOLEAN,\n        value: serialized\n      };\n    } // JavaScript numbers can be Int or Float values.\n\n\n    if (typeof serialized === 'number' && Number.isFinite(serialized)) {\n      const stringNum = String(serialized);\n      return integerStringRegExp.test(stringNum) ? {\n        kind: Kind.INT,\n        value: stringNum\n      } : {\n        kind: Kind.FLOAT,\n        value: stringNum\n      };\n    }\n\n    if (typeof serialized === 'string') {\n      // Enum types use Enum literals.\n      if (isEnumType(type)) {\n        return {\n          kind: Kind.ENUM,\n          value: serialized\n        };\n      } // ID types can use Int literals.\n\n\n      if (type === GraphQLID && integerStringRegExp.test(serialized)) {\n        return {\n          kind: Kind.INT,\n          value: serialized\n        };\n      }\n\n      return {\n        kind: Kind.STRING,\n        value: serialized\n      };\n    }\n\n    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n\n  false || invariant(false, 'Unexpected input type: ' + inspect(type));\n}\n/**\r\n * IntValue:\r\n *   - NegativeSign? 0\r\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\r\n */\n\nconst integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;","map":{"version":3,"sources":["C:/BootCamp/Book-Search-21/node_modules/graphql/utilities/astFromValue.mjs"],"names":["inspect","invariant","isObjectLike","isIterableObject","Kind","GraphQLID","isLeafType","isEnumType","isInputObjectType","isListType","isNonNullType","astFromValue","value","type","astValue","ofType","kind","NULL","undefined","itemType","valuesNodes","item","itemNode","push","LIST","values","fieldNodes","field","Object","getFields","fieldValue","name","OBJECT_FIELD","NAME","OBJECT","fields","serialized","serialize","BOOLEAN","Number","isFinite","stringNum","String","integerStringRegExp","test","INT","FLOAT","ENUM","STRING","TypeError"],"mappings":"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","sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\r\nimport { invariant } from '../jsutils/invariant.mjs';\r\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\r\nimport { isIterableObject } from '../jsutils/isIterableObject.mjs';\r\nimport { Kind } from '../language/kinds.mjs';\r\nimport { GraphQLID } from '../type/scalars.mjs';\r\nimport {\r\n  isLeafType,\r\n  isEnumType,\r\n  isInputObjectType,\r\n  isListType,\r\n  isNonNullType,\r\n} from '../type/definition.mjs';\r\n/**\r\n * Produces a GraphQL Value AST given a JavaScript object.\r\n * Function will match JavaScript/JSON values to GraphQL AST schema format\r\n * by using suggested GraphQLInputType. For example:\r\n *\r\n *     astFromValue(\"value\", GraphQLString)\r\n *\r\n * A GraphQL type must be provided, which will be used to interpret different\r\n * JavaScript values.\r\n *\r\n * | JSON Value    | GraphQL Value        |\r\n * | ------------- | -------------------- |\r\n * | Object        | Input Object         |\r\n * | Array         | List                 |\r\n * | Boolean       | Boolean              |\r\n * | String        | String / Enum Value  |\r\n * | Number        | Int / Float          |\r\n * | Unknown       | Enum Value           |\r\n * | null          | NullValue            |\r\n *\r\n */\r\n\r\nexport function astFromValue(value, type) {\r\n  if (isNonNullType(type)) {\r\n    const astValue = astFromValue(value, type.ofType);\r\n\r\n    if (\r\n      (astValue === null || astValue === void 0 ? void 0 : astValue.kind) ===\r\n      Kind.NULL\r\n    ) {\r\n      return null;\r\n    }\r\n\r\n    return astValue;\r\n  } // only explicit null, not undefined, NaN\r\n\r\n  if (value === null) {\r\n    return {\r\n      kind: Kind.NULL,\r\n    };\r\n  } // undefined\r\n\r\n  if (value === undefined) {\r\n    return null;\r\n  } // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\r\n  // the value is not an array, convert the value using the list's item type.\r\n\r\n  if (isListType(type)) {\r\n    const itemType = type.ofType;\r\n\r\n    if (isIterableObject(value)) {\r\n      const valuesNodes = [];\r\n\r\n      for (const item of value) {\r\n        const itemNode = astFromValue(item, itemType);\r\n\r\n        if (itemNode != null) {\r\n          valuesNodes.push(itemNode);\r\n        }\r\n      }\r\n\r\n      return {\r\n        kind: Kind.LIST,\r\n        values: valuesNodes,\r\n      };\r\n    }\r\n\r\n    return astFromValue(value, itemType);\r\n  } // Populate the fields of the input object by creating ASTs from each value\r\n  // in the JavaScript object according to the fields in the input type.\r\n\r\n  if (isInputObjectType(type)) {\r\n    if (!isObjectLike(value)) {\r\n      return null;\r\n    }\r\n\r\n    const fieldNodes = [];\r\n\r\n    for (const field of Object.values(type.getFields())) {\r\n      const fieldValue = astFromValue(value[field.name], field.type);\r\n\r\n      if (fieldValue) {\r\n        fieldNodes.push({\r\n          kind: Kind.OBJECT_FIELD,\r\n          name: {\r\n            kind: Kind.NAME,\r\n            value: field.name,\r\n          },\r\n          value: fieldValue,\r\n        });\r\n      }\r\n    }\r\n\r\n    return {\r\n      kind: Kind.OBJECT,\r\n      fields: fieldNodes,\r\n    };\r\n  }\r\n\r\n  if (isLeafType(type)) {\r\n    // Since value is an internally represented value, it must be serialized\r\n    // to an externally represented value before converting into an AST.\r\n    const serialized = type.serialize(value);\r\n\r\n    if (serialized == null) {\r\n      return null;\r\n    } // Others serialize based on their corresponding JavaScript scalar types.\r\n\r\n    if (typeof serialized === 'boolean') {\r\n      return {\r\n        kind: Kind.BOOLEAN,\r\n        value: serialized,\r\n      };\r\n    } // JavaScript numbers can be Int or Float values.\r\n\r\n    if (typeof serialized === 'number' && Number.isFinite(serialized)) {\r\n      const stringNum = String(serialized);\r\n      return integerStringRegExp.test(stringNum)\r\n        ? {\r\n            kind: Kind.INT,\r\n            value: stringNum,\r\n          }\r\n        : {\r\n            kind: Kind.FLOAT,\r\n            value: stringNum,\r\n          };\r\n    }\r\n\r\n    if (typeof serialized === 'string') {\r\n      // Enum types use Enum literals.\r\n      if (isEnumType(type)) {\r\n        return {\r\n          kind: Kind.ENUM,\r\n          value: serialized,\r\n        };\r\n      } // ID types can use Int literals.\r\n\r\n      if (type === GraphQLID && integerStringRegExp.test(serialized)) {\r\n        return {\r\n          kind: Kind.INT,\r\n          value: serialized,\r\n        };\r\n      }\r\n\r\n      return {\r\n        kind: Kind.STRING,\r\n        value: serialized,\r\n      };\r\n    }\r\n\r\n    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);\r\n  }\r\n  /* c8 ignore next 3 */\r\n  // Not reachable, all possible types have been considered.\r\n\r\n  false || invariant(false, 'Unexpected input type: ' + inspect(type));\r\n}\r\n/**\r\n * IntValue:\r\n *   - NegativeSign? 0\r\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\r\n */\r\n\r\nconst integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\r\n"]},"metadata":{},"sourceType":"module"}