{"ast":null,"code":"/**\r\n * Contains a range of UTF-8 character offsets and token references that\r\n * identify the region of the source from which the AST derived.\r\n */\nexport class Location {\n  /**\r\n   * The character offset at which this Node begins.\r\n   */\n\n  /**\r\n   * The character offset at which this Node ends.\r\n   */\n\n  /**\r\n   * The Token at which this Node begins.\r\n   */\n\n  /**\r\n   * The Token at which this Node ends.\r\n   */\n\n  /**\r\n   * The Source document the AST represents.\r\n   */\n  constructor(startToken, endToken, source) {\n    this.start = startToken.start;\n    this.end = endToken.end;\n    this.startToken = startToken;\n    this.endToken = endToken;\n    this.source = source;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Location';\n  }\n\n  toJSON() {\n    return {\n      start: this.start,\n      end: this.end\n    };\n  }\n\n}\n/**\r\n * Represents a range of characters represented by a lexical token\r\n * within a Source.\r\n */\n\nexport class Token {\n  /**\r\n   * The kind of Token.\r\n   */\n\n  /**\r\n   * The character offset at which this Node begins.\r\n   */\n\n  /**\r\n   * The character offset at which this Node ends.\r\n   */\n\n  /**\r\n   * The 1-indexed line number on which this Token appears.\r\n   */\n\n  /**\r\n   * The 1-indexed column number at which this Token begins.\r\n   */\n\n  /**\r\n   * For non-punctuation tokens, represents the interpreted value of the token.\r\n   *\r\n   * Note: is undefined for punctuation tokens, but typed as string for\r\n   * convenience in the parser.\r\n   */\n\n  /**\r\n   * Tokens exist as nodes in a double-linked-list amongst all tokens\r\n   * including ignored tokens. <SOF> is always the first node and <EOF>\r\n   * the last.\r\n   */\n  constructor(kind, start, end, line, column, value) {\n    this.kind = kind;\n    this.start = start;\n    this.end = end;\n    this.line = line;\n    this.column = column; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Token';\n  }\n\n  toJSON() {\n    return {\n      kind: this.kind,\n      value: this.value,\n      line: this.line,\n      column: this.column\n    };\n  }\n\n}\n/**\r\n * The list of all possible AST node types.\r\n */\n\n/**\r\n * @internal\r\n */\n\nexport const QueryDocumentKeys = {\n  Name: [],\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name', // Note: fragment variable definitions are deprecated and will removed in v17.0.0\n  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n  Directive: ['name', 'arguments'],\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n  SchemaDefinition: ['description', 'directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\n  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],\n  InterfaceTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\n  EnumValueDefinition: ['description', 'name', 'directives'],\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],\n  SchemaExtension: ['directives', 'operationTypes'],\n  ScalarTypeExtension: ['name', 'directives'],\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  InterfaceTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  UnionTypeExtension: ['name', 'directives', 'types'],\n  EnumTypeExtension: ['name', 'directives', 'values'],\n  InputObjectTypeExtension: ['name', 'directives', 'fields']\n};\nconst kindValues = new Set(Object.keys(QueryDocumentKeys));\n/**\r\n * @internal\r\n */\n\nexport function isNode(maybeNode) {\n  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;\n  return typeof maybeKind === 'string' && kindValues.has(maybeKind);\n}\n/** Name */\n\nexport let OperationTypeNode;\n\n(function (OperationTypeNode) {\n  OperationTypeNode['QUERY'] = 'query';\n  OperationTypeNode['MUTATION'] = 'mutation';\n  OperationTypeNode['SUBSCRIPTION'] = 'subscription';\n})(OperationTypeNode || (OperationTypeNode = {}));","map":{"version":3,"sources":["C:/BootCamp/Book-Search-21/node_modules/graphql/language/ast.mjs"],"names":["Location","constructor","startToken","endToken","source","start","end","Symbol","toStringTag","toJSON","Token","kind","line","column","value","prev","next","QueryDocumentKeys","Name","Document","OperationDefinition","VariableDefinition","Variable","SelectionSet","Field","Argument","FragmentSpread","InlineFragment","FragmentDefinition","IntValue","FloatValue","StringValue","BooleanValue","NullValue","EnumValue","ListValue","ObjectValue","ObjectField","Directive","NamedType","ListType","NonNullType","SchemaDefinition","OperationTypeDefinition","ScalarTypeDefinition","ObjectTypeDefinition","FieldDefinition","InputValueDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","EnumValueDefinition","InputObjectTypeDefinition","DirectiveDefinition","SchemaExtension","ScalarTypeExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","kindValues","Set","Object","keys","isNode","maybeNode","maybeKind","has","OperationTypeNode"],"mappings":"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","sourcesContent":["/**\r\n * Contains a range of UTF-8 character offsets and token references that\r\n * identify the region of the source from which the AST derived.\r\n */\r\nexport class Location {\r\n  /**\r\n   * The character offset at which this Node begins.\r\n   */\r\n\r\n  /**\r\n   * The character offset at which this Node ends.\r\n   */\r\n\r\n  /**\r\n   * The Token at which this Node begins.\r\n   */\r\n\r\n  /**\r\n   * The Token at which this Node ends.\r\n   */\r\n\r\n  /**\r\n   * The Source document the AST represents.\r\n   */\r\n  constructor(startToken, endToken, source) {\r\n    this.start = startToken.start;\r\n    this.end = endToken.end;\r\n    this.startToken = startToken;\r\n    this.endToken = endToken;\r\n    this.source = source;\r\n  }\r\n\r\n  get [Symbol.toStringTag]() {\r\n    return 'Location';\r\n  }\r\n\r\n  toJSON() {\r\n    return {\r\n      start: this.start,\r\n      end: this.end,\r\n    };\r\n  }\r\n}\r\n/**\r\n * Represents a range of characters represented by a lexical token\r\n * within a Source.\r\n */\r\n\r\nexport class Token {\r\n  /**\r\n   * The kind of Token.\r\n   */\r\n\r\n  /**\r\n   * The character offset at which this Node begins.\r\n   */\r\n\r\n  /**\r\n   * The character offset at which this Node ends.\r\n   */\r\n\r\n  /**\r\n   * The 1-indexed line number on which this Token appears.\r\n   */\r\n\r\n  /**\r\n   * The 1-indexed column number at which this Token begins.\r\n   */\r\n\r\n  /**\r\n   * For non-punctuation tokens, represents the interpreted value of the token.\r\n   *\r\n   * Note: is undefined for punctuation tokens, but typed as string for\r\n   * convenience in the parser.\r\n   */\r\n\r\n  /**\r\n   * Tokens exist as nodes in a double-linked-list amongst all tokens\r\n   * including ignored tokens. <SOF> is always the first node and <EOF>\r\n   * the last.\r\n   */\r\n  constructor(kind, start, end, line, column, value) {\r\n    this.kind = kind;\r\n    this.start = start;\r\n    this.end = end;\r\n    this.line = line;\r\n    this.column = column; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n\r\n    this.value = value;\r\n    this.prev = null;\r\n    this.next = null;\r\n  }\r\n\r\n  get [Symbol.toStringTag]() {\r\n    return 'Token';\r\n  }\r\n\r\n  toJSON() {\r\n    return {\r\n      kind: this.kind,\r\n      value: this.value,\r\n      line: this.line,\r\n      column: this.column,\r\n    };\r\n  }\r\n}\r\n/**\r\n * The list of all possible AST node types.\r\n */\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const QueryDocumentKeys = {\r\n  Name: [],\r\n  Document: ['definitions'],\r\n  OperationDefinition: [\r\n    'name',\r\n    'variableDefinitions',\r\n    'directives',\r\n    'selectionSet',\r\n  ],\r\n  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],\r\n  Variable: ['name'],\r\n  SelectionSet: ['selections'],\r\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\r\n  Argument: ['name', 'value'],\r\n  FragmentSpread: ['name', 'directives'],\r\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\r\n  FragmentDefinition: [\r\n    'name', // Note: fragment variable definitions are deprecated and will removed in v17.0.0\r\n    'variableDefinitions',\r\n    'typeCondition',\r\n    'directives',\r\n    'selectionSet',\r\n  ],\r\n  IntValue: [],\r\n  FloatValue: [],\r\n  StringValue: [],\r\n  BooleanValue: [],\r\n  NullValue: [],\r\n  EnumValue: [],\r\n  ListValue: ['values'],\r\n  ObjectValue: ['fields'],\r\n  ObjectField: ['name', 'value'],\r\n  Directive: ['name', 'arguments'],\r\n  NamedType: ['name'],\r\n  ListType: ['type'],\r\n  NonNullType: ['type'],\r\n  SchemaDefinition: ['description', 'directives', 'operationTypes'],\r\n  OperationTypeDefinition: ['type'],\r\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\r\n  ObjectTypeDefinition: [\r\n    'description',\r\n    'name',\r\n    'interfaces',\r\n    'directives',\r\n    'fields',\r\n  ],\r\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\r\n  InputValueDefinition: [\r\n    'description',\r\n    'name',\r\n    'type',\r\n    'defaultValue',\r\n    'directives',\r\n  ],\r\n  InterfaceTypeDefinition: [\r\n    'description',\r\n    'name',\r\n    'interfaces',\r\n    'directives',\r\n    'fields',\r\n  ],\r\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\r\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\r\n  EnumValueDefinition: ['description', 'name', 'directives'],\r\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\r\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],\r\n  SchemaExtension: ['directives', 'operationTypes'],\r\n  ScalarTypeExtension: ['name', 'directives'],\r\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\r\n  InterfaceTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\r\n  UnionTypeExtension: ['name', 'directives', 'types'],\r\n  EnumTypeExtension: ['name', 'directives', 'values'],\r\n  InputObjectTypeExtension: ['name', 'directives', 'fields'],\r\n};\r\nconst kindValues = new Set(Object.keys(QueryDocumentKeys));\r\n/**\r\n * @internal\r\n */\r\n\r\nexport function isNode(maybeNode) {\r\n  const maybeKind =\r\n    maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;\r\n  return typeof maybeKind === 'string' && kindValues.has(maybeKind);\r\n}\r\n/** Name */\r\n\r\nexport let OperationTypeNode;\r\n\r\n(function (OperationTypeNode) {\r\n  OperationTypeNode['QUERY'] = 'query';\r\n  OperationTypeNode['MUTATION'] = 'mutation';\r\n  OperationTypeNode['SUBSCRIPTION'] = 'subscription';\r\n})(OperationTypeNode || (OperationTypeNode = {}));\r\n"]},"metadata":{},"sourceType":"module"}