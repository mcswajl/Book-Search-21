{"ast":null,"code":"import { Kind } from '../language/kinds.mjs';\nimport { GraphQLIncludeDirective, GraphQLSkipDirective } from '../type/directives.mjs';\nimport { isAbstractType } from '../type/definition.mjs';\nimport { typeFromAST } from '../utilities/typeFromAST.mjs';\nimport { getDirectiveValues } from './values.mjs';\n/**\r\n * Given a selectionSet, collects all of the fields and returns them.\r\n *\r\n * CollectFields requires the \"runtime type\" of an object. For a field that\r\n * returns an Interface or Union type, the \"runtime type\" will be the actual\r\n * object type returned by that field.\r\n *\r\n * @internal\r\n */\n\nexport function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {\n  const fields = new Map();\n  collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, new Set());\n  return fields;\n}\n/**\r\n * Given an array of field nodes, collects all of the subfields of the passed\r\n * in fields, and returns them at the end.\r\n *\r\n * CollectSubFields requires the \"return type\" of an object. For a field that\r\n * returns an Interface or Union type, the \"return type\" will be the actual\r\n * object type returned by that field.\r\n *\r\n * @internal\r\n */\n\nexport function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {\n  const subFieldNodes = new Map();\n  const visitedFragmentNames = new Set();\n\n  for (const node of fieldNodes) {\n    if (node.selectionSet) {\n      collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);\n    }\n  }\n\n  return subFieldNodes;\n}\n\nfunction collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD:\n        {\n          if (!shouldIncludeNode(variableValues, selection)) {\n            continue;\n          }\n\n          const name = getFieldEntryKey(selection);\n          const fieldList = fields.get(name);\n\n          if (fieldList !== undefined) {\n            fieldList.push(selection);\n          } else {\n            fields.set(name, [selection]);\n          }\n\n          break;\n        }\n\n      case Kind.INLINE_FRAGMENT:\n        {\n          if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n            continue;\n          }\n\n          collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n\n      case Kind.FRAGMENT_SPREAD:\n        {\n          const fragName = selection.name.value;\n\n          if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {\n            continue;\n          }\n\n          visitedFragmentNames.add(fragName);\n          const fragment = fragments[fragName];\n\n          if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n            continue;\n          }\n\n          collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n    }\n  }\n}\n/**\r\n * Determines if a field should be included based on the `@include` and `@skip`\r\n * directives, where `@skip` has higher precedence than `@include`.\r\n */\n\n\nfunction shouldIncludeNode(variableValues, node) {\n  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);\n\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\n    return false;\n  }\n\n  const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);\n\n  if ((include === null || include === void 0 ? void 0 : include.if) === false) {\n    return false;\n  }\n\n  return true;\n}\n/**\r\n * Determines if a fragment is applicable to the given type.\r\n */\n\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  const typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  const conditionalType = typeFromAST(schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if (isAbstractType(conditionalType)) {\n    return schema.isSubType(conditionalType, type);\n  }\n\n  return false;\n}\n/**\r\n * Implements the logic to compute the key of a given field's entry\r\n */\n\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}","map":{"version":3,"sources":["C:/BootCamp/Book-Search-21/node_modules/graphql/execution/collectFields.mjs"],"names":["Kind","GraphQLIncludeDirective","GraphQLSkipDirective","isAbstractType","typeFromAST","getDirectiveValues","collectFields","schema","fragments","variableValues","runtimeType","selectionSet","fields","Map","collectFieldsImpl","Set","collectSubfields","returnType","fieldNodes","subFieldNodes","visitedFragmentNames","node","selection","selections","kind","FIELD","shouldIncludeNode","name","getFieldEntryKey","fieldList","get","undefined","push","set","INLINE_FRAGMENT","doesFragmentConditionMatch","FRAGMENT_SPREAD","fragName","value","has","add","fragment","skip","if","include","type","typeConditionNode","typeCondition","conditionalType","isSubType","alias"],"mappings":"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","sourcesContent":["import { Kind } from '../language/kinds.mjs';\r\nimport {\r\n  GraphQLIncludeDirective,\r\n  GraphQLSkipDirective,\r\n} from '../type/directives.mjs';\r\nimport { isAbstractType } from '../type/definition.mjs';\r\nimport { typeFromAST } from '../utilities/typeFromAST.mjs';\r\nimport { getDirectiveValues } from './values.mjs';\r\n/**\r\n * Given a selectionSet, collects all of the fields and returns them.\r\n *\r\n * CollectFields requires the \"runtime type\" of an object. For a field that\r\n * returns an Interface or Union type, the \"runtime type\" will be the actual\r\n * object type returned by that field.\r\n *\r\n * @internal\r\n */\r\n\r\nexport function collectFields(\r\n  schema,\r\n  fragments,\r\n  variableValues,\r\n  runtimeType,\r\n  selectionSet,\r\n) {\r\n  const fields = new Map();\r\n  collectFieldsImpl(\r\n    schema,\r\n    fragments,\r\n    variableValues,\r\n    runtimeType,\r\n    selectionSet,\r\n    fields,\r\n    new Set(),\r\n  );\r\n  return fields;\r\n}\r\n/**\r\n * Given an array of field nodes, collects all of the subfields of the passed\r\n * in fields, and returns them at the end.\r\n *\r\n * CollectSubFields requires the \"return type\" of an object. For a field that\r\n * returns an Interface or Union type, the \"return type\" will be the actual\r\n * object type returned by that field.\r\n *\r\n * @internal\r\n */\r\n\r\nexport function collectSubfields(\r\n  schema,\r\n  fragments,\r\n  variableValues,\r\n  returnType,\r\n  fieldNodes,\r\n) {\r\n  const subFieldNodes = new Map();\r\n  const visitedFragmentNames = new Set();\r\n\r\n  for (const node of fieldNodes) {\r\n    if (node.selectionSet) {\r\n      collectFieldsImpl(\r\n        schema,\r\n        fragments,\r\n        variableValues,\r\n        returnType,\r\n        node.selectionSet,\r\n        subFieldNodes,\r\n        visitedFragmentNames,\r\n      );\r\n    }\r\n  }\r\n\r\n  return subFieldNodes;\r\n}\r\n\r\nfunction collectFieldsImpl(\r\n  schema,\r\n  fragments,\r\n  variableValues,\r\n  runtimeType,\r\n  selectionSet,\r\n  fields,\r\n  visitedFragmentNames,\r\n) {\r\n  for (const selection of selectionSet.selections) {\r\n    switch (selection.kind) {\r\n      case Kind.FIELD: {\r\n        if (!shouldIncludeNode(variableValues, selection)) {\r\n          continue;\r\n        }\r\n\r\n        const name = getFieldEntryKey(selection);\r\n        const fieldList = fields.get(name);\r\n\r\n        if (fieldList !== undefined) {\r\n          fieldList.push(selection);\r\n        } else {\r\n          fields.set(name, [selection]);\r\n        }\r\n\r\n        break;\r\n      }\r\n\r\n      case Kind.INLINE_FRAGMENT: {\r\n        if (\r\n          !shouldIncludeNode(variableValues, selection) ||\r\n          !doesFragmentConditionMatch(schema, selection, runtimeType)\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        collectFieldsImpl(\r\n          schema,\r\n          fragments,\r\n          variableValues,\r\n          runtimeType,\r\n          selection.selectionSet,\r\n          fields,\r\n          visitedFragmentNames,\r\n        );\r\n        break;\r\n      }\r\n\r\n      case Kind.FRAGMENT_SPREAD: {\r\n        const fragName = selection.name.value;\r\n\r\n        if (\r\n          visitedFragmentNames.has(fragName) ||\r\n          !shouldIncludeNode(variableValues, selection)\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        visitedFragmentNames.add(fragName);\r\n        const fragment = fragments[fragName];\r\n\r\n        if (\r\n          !fragment ||\r\n          !doesFragmentConditionMatch(schema, fragment, runtimeType)\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        collectFieldsImpl(\r\n          schema,\r\n          fragments,\r\n          variableValues,\r\n          runtimeType,\r\n          fragment.selectionSet,\r\n          fields,\r\n          visitedFragmentNames,\r\n        );\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n/**\r\n * Determines if a field should be included based on the `@include` and `@skip`\r\n * directives, where `@skip` has higher precedence than `@include`.\r\n */\r\n\r\nfunction shouldIncludeNode(variableValues, node) {\r\n  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);\r\n\r\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\r\n    return false;\r\n  }\r\n\r\n  const include = getDirectiveValues(\r\n    GraphQLIncludeDirective,\r\n    node,\r\n    variableValues,\r\n  );\r\n\r\n  if (\r\n    (include === null || include === void 0 ? void 0 : include.if) === false\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n/**\r\n * Determines if a fragment is applicable to the given type.\r\n */\r\n\r\nfunction doesFragmentConditionMatch(schema, fragment, type) {\r\n  const typeConditionNode = fragment.typeCondition;\r\n\r\n  if (!typeConditionNode) {\r\n    return true;\r\n  }\r\n\r\n  const conditionalType = typeFromAST(schema, typeConditionNode);\r\n\r\n  if (conditionalType === type) {\r\n    return true;\r\n  }\r\n\r\n  if (isAbstractType(conditionalType)) {\r\n    return schema.isSubType(conditionalType, type);\r\n  }\r\n\r\n  return false;\r\n}\r\n/**\r\n * Implements the logic to compute the key of a given field's entry\r\n */\r\n\r\nfunction getFieldEntryKey(node) {\r\n  return node.alias ? node.alias.value : node.name.value;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}